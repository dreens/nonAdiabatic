%% Load E-field data for hop checking.
% nonAd.m loads data from nonadiabatic.dat generated by COMSOL

tic
fprintf('Loading File: ')
all = importdata('nonadiabatic.dat',' ',9);
all = all.data;
toc
fprintf('Reading xyz columns: ')
x = all(:,1);
y = all(:,2);
z = all(:,3);
toc

% x,y have same range, z different. Get lookups that tell you, given
% an x vale x0, what ordinal it is, e.g. the 5th x-value.
ux = unique(x);
np = length(ux);
uz = unique(z);
npz = length(uz);
ntp = np*np*npz;
sp = max(diff(ux));
spz = max(diff(uz));
mp = min(ux);
mpz = min(uz);
l = @(x0) int16((x0 - mp)/sp + 1);
lz = @(z0) int16((z0 - mpz)/spz + 1);

% Get a single dimension matrix lookup index out of a triple index, for
% each row of the input data file.
fprintf('Loading linear indices: ')
xyz = sub2ind([np np npz],l(x),l(y),lz(z));
toc

% Initialize all matrices
Ex = zeros([np np npz]);
Ey = zeros([np np npz]);
Ez = zeros([np np npz]);
xx = zeros([np np npz]);
yy = zeros([np np npz]);
zz = zeros([np np npz]);


% Fill all matrices
fprintf('Filling Matrices: ')
xx(xyz) = x;
yy(xyz) = y;
zz(xyz) = z;
Ex(xyz) = all(:,4);
Ey(xyz) = all(:,5);
Ez(xyz) = all(:,6);
toc

% Remove NaNs
nn(xyz) = isnan(Ex);
fprintf('NaNs: %d',sum(nn(:)))

Ex(nn) = 0;
Ey(nn) = 0;
Ez(nn) = 0;

%% Plot minimum electric field along trajectories
% Show the min e-field along trajectories:
En = sqrt(Ex.^2+Ey.^2+Ez.^2);
Emin = min(En,[],3)/1e5;
figure;
%pcolor(xx(:,:,1),yy(:,:,1),Emin)
[xxx, yyy] = meshgrid(-1000:50:1000,-1000:50:1000);
tallr = [flipud(Emin) ; Emin(2:end,:)];
wider = [fliplr(tallr) tallr(:,2:end)];
contourf(xxx,yyy,wider)
title('Minimum Energy Gap along trajectories')
xlabel('Distance towards Pin (\mum)')
ylabel('Distance along Pin (\mum)')
h = colorbar;
ylabel(h,'Electric Field (kV/cm)')
%% We need an electric field to gap converter:
e = [0:1e4:9e4 logspace(5,9,50)];
h = e;
for i=1:length(e)
    hh = OH_Ham_Lab_Fixed(0,0,0,e(i),0,0);
    d = diff(sort(eig(hh)));
    h(i) = d(end-1);
end
sp = spapi(3,e,h);
gap = @(efield) fnval(sp,efield);
%% Plot minimum gap along trajectories
% Like before but using gap converter
figure;
%pcolor(xx(:,:,1),yy(:,:,1),gap(Emin)/(6.626e-28))
contourf(xxx,yyy,gap(wider*1e5)/(6.626e-28))
title('Minimum Energy Gap along trajectories')
xlabel('Distance towards Pin (\mum)')
ylabel('Distance along Pin (\mum)')
h = colorbar;
ylabel(h,'Gap (MHz)')


%% Plot it to confirm behavior
figure;
plot(e*1e-5,h/(6.626e-28),'r*')
dense = logspace(4,9,1000);
hold on
grid on
plot(dense*1e-5,gap(dense)/(6.626e-28),'b-')
title('Field to Gap Converter')
set(gca,'XScale','log')
xlabel('E-field (kV/cm)')
ylabel('Energy (MHz)')
set(gca,'YScale','log')
%% Plot Energy along trajectories, conglomerated.
figure;
grid on
title('Energy Gap Along Trajectories')
xlabel('Distance from Minimum Energy (mm)')
ylabel('Energy Gap f3/2 to f1/2 (MHz)')
hold on
for i=1:21
    for j=1:21
        plot(squeeze(zz(1,1,:)+5.461),gap(squeeze(En(i,j,:)))/6.626e-28)
    end
end
xlim([-1.2 1.2])

%% Now we can generate rows of Hamiltonians from these.
% This is taking too long. Thoughts?
% convert to a 4x4? -nothing obvious about how to do it. Need lin alg book
% I think.
% is the cacheing a problem?? Let's knock it out and see. No, it is working
% just fine.
xc = 21;
yc = 1;
out = checkHops(zz(xc,yc,:),Ex(xc,yc,:),Ey(xc,yc,:),Ez(xc,yc,:),750000);

%% Back from Cluster
% 
[xxx, yyy] = meshgrid(-1000:50:1000,-1000:50:1000);
r = load('rc21x21.mat');
r = r.r;
tallr = [flipud(r) ; r(2:end,:)];
wider = [fliplr(tallr) tallr(:,2:end)];
figure;
contourf(xxx,yyy,log10(wider))
cb = colorbar;
ylabel(cb,'Log Hop Probability')
ylabel('Distance between pins')
xlabel('Distance along pins')
title('Hopping Probability')